    11: int main() { 
    12:     uint8_t *p; 
    13:     uint8_t *rgba; //uint8_t rgba[IMAGE_SIZE]; //RGBA array 
    14:     uint8_t *rgb; //uint8_t rgb[IMAGE_SIZE * 3/4]; //RGB array 
    15:     uint8_t *rgbcomp; //uint8_t rgbcomp[IMAGE_SIZE / 4]; //compressed RGB 
0x00000554  E92D4FFE  STMDB     R13!,{R1-R11,R14}
    16:     p = 0x40000000; //memory pointer - size 4000byte 
0x00000558  E3A00101  MOV       R0,#__stdout(0x40000000)
0x0000055C  E58D0008  STR       R0,[R13,#0x0008]
    17:     rgba = 0x40200000; 
0x00000560  E180A4C0  ORR       R10,R0,R0,ASR #9
    18:     rgb = 0x40400000; 
0x00000564  E1800440  ORR       R0,R0,R0,ASR #8
0x00000568  E58D0004  STR       R0,[R13,#0x0004]
    19:     rgbcomp = 0x40600000; 
    20:     //0x40200000, 0x407FFFFF Memory Map needed 
0x0000056C  E2800602  ADD       R0,R0,#0x00200000
0x00000570  E58D0000  STR       R0,[R13]
    21:     size_t i = 0; 
0x00000574  E3A04000  MOV       R4,#0x00000000
    22:     size_t j = 0; 
0x00000578  E3A05000  MOV       R5,#0x00000000
    23:     size_t k = 0; 
    24:  
0x0000057C  E3A08000  MOV       R8,#0x00000000
    25:     p = 0x40000000 + HEADER_SIZE;   //fseek(fileIn, HEADER_SIZE-1, SEEK_SET); //set pointer after header 
0x00000580  E3A001D9  MOV       R0,#0x40000036
0x00000584  E58D0008  STR       R0,[R13,#0x0008]
    26:     for(i = 0 ; i<IMAGE_SIZE; i++){ 
0x00000588  E1A00000  NOP       
0x0000058C  EA000003  B         0x000005A0
    27:         rgba[i] = p[i]; 
    28:     } //fread(rgba, sizeof(uint8_t), IMAGE_SIZE, fileIn); //Whole rgba read 
    29:      
0x00000590  E59D0008  LDR       R0,[R13,#0x0008]
0x00000594  E7D00004  LDRB      R0,[R0,R4]
0x00000598  E7CA0004  STRB      R0,[R10,R4]
0x0000059C  E2844001  ADD       R4,R4,#0x00000001
0x000005A0  E3540A96  CMP       R4,#0x00096000
0x000005A4  3AFFFFF9  BCC       0x00000590
    30:     for (k = 0; k < 3; k++){ //R, G, B  *3 times 
0x000005A8  E3A08000  MOV       R8,#0x00000000
0x000005AC  EA00000B  B         0x000005E0
    31:         for (i = 0; i < IMAGE_SIZE; i += 4) { 
0x000005B0  E3A04000  MOV       R4,#0x00000000
0x000005B4  EA000006  B         0x000005D4
    32:             rgb[j++] = rgba[i+k];     // RRRGGGBBB order 
    33:         } // Convert RGBA to RGB by ignoring the alpha channel 
    34:     } 
    35:  
0x000005B8  E0840008  ADD       R0,R4,R8
0x000005BC  E7DA2000  LDRB      R2,[R10,R0]
0x000005C0  E1A00005  MOV       R0,R5
0x000005C4  E2855001  ADD       R5,R5,#0x00000001
0x000005C8  E59D1004  LDR       R1,[R13,#0x0004]
0x000005CC  E7C12000  STRB      R2,[R1,R0]
0x000005D0  E2844004  ADD       R4,R4,#0x00000004
0x000005D4  E3540A96  CMP       R4,#0x00096000
0x000005D8  3AFFFFF6  BCC       0x000005B8
    30:     for (k = 0; k < 3; k++){ //R, G, B  *3 times 
    31:         for (i = 0; i < IMAGE_SIZE; i += 4) { 
    32:             rgb[j++] = rgba[i+k];     // RRRGGGBBB order 
    33:         } // Convert RGBA to RGB by ignoring the alpha channel 
    34:     } 
    35:  
0x000005DC  E2888001  ADD       R8,R8,#0x00000001
0x000005E0  E3580003  CMP       R8,#0x00000003
0x000005E4  3AFFFFF1  BCC       0x000005B0
    36:     uint32_t mask = 0xE0E0E0E0; //masking 0b1110_0000 by register length 
0x000005E8  E59F90D0  LDR       R9,[PC,#0x00D0]
    37:     int32_t bmask = 0xC0C0C0C0; 
    38:     uint32_t *regtmp; 
    39:     uint32_t *readbuffer; 
0x000005EC  E1C9B129  BIC       R11,R9,R9,LSR #2
    40:     readbuffer = 0x40400000; 
0x000005F0  E00B7789  AND       R7,R11,R9,LSL #15
    41:     regtmp = 0x40600000; 
0x000005F4  E2876602  ADD       R6,R7,#0x00200000
    42:     i = 0; 
0x000005F8  E3A04000  MOV       R4,#0x00000000
    43:         j=0; 
0x000005FC  E3A05000  MOV       R5,#0x00000000
    44:     while (j < IMAGE_SIZE/16) { 
0x00000600  EA000009  B         0x0000062C
    45:         regtmp[j++] += readbuffer[i++]&mask; 
    46:     } 
0x00000604  E1A01005  MOV       R1,R5
0x00000608  E2855001  ADD       R5,R5,#0x00000001
0x0000060C  E0860101  ADD       R0,R6,R1,LSL #2
0x00000610  E1A01004  MOV       R1,R4
0x00000614  E2844001  ADD       R4,R4,#0x00000001
0x00000618  E5902000  LDR       R2,[R0]
0x0000061C  E7971101  LDR       R1,[R7,R1,LSL #2]
0x00000620  E0011009  AND       R1,R1,R9
0x00000624  E0811002  ADD       R1,R1,R2
0x00000628  E5801000  STR       R1,[R0]
0x0000062C  E3550C96  CMP       R5,#0x00009600
0x00000630  3AFFFFF3  BCC       0x00000604
    47:     j=0; 
0x00000634  E3A05000  MOV       R5,#0x00000000
    48:     while (j < IMAGE_SIZE/16) { 
0x00000638  EA000009  B         0x00000664
    49:         regtmp[j++] += (readbuffer[i++]&mask) >> 3; 
    50:     } 
0x0000063C  E1A01005  MOV       R1,R5
0x00000640  E2855001  ADD       R5,R5,#0x00000001
0x00000644  E0860101  ADD       R0,R6,R1,LSL #2
0x00000648  E1A01004  MOV       R1,R4
0x0000064C  E2844001  ADD       R4,R4,#0x00000001
0x00000650  E5902000  LDR       R2,[R0]
0x00000654  E7971101  LDR       R1,[R7,R1,LSL #2]
0x00000658  E0011009  AND       R1,R1,R9
0x0000065C  E08211A1  ADD       R1,R2,R1,LSR #3
0x00000660  E5801000  STR       R1,[R0]
0x00000664  E3550C96  CMP       R5,#0x00009600
0x00000668  3AFFFFF3  BCC       0x0000063C
    51:     j=0; 
0x0000066C  E3A05000  MOV       R5,#0x00000000
    52:     while (j < IMAGE_SIZE/16) { 
0x00000670  EA000009  B         0x0000069C
    53:         regtmp[j++] += (readbuffer[i++]&bmask) >> 6; 
    54:     } 
    55:         /* //?? 3?? while?? ?? ?? 
    56:         for(k = 0; k < 3; k++){ 
    57:         j = 0; 
    58:         while (j < IMAGE_SIZE/16 && k < 2) { 
    59:             regtmp[j++] += readbuffer[i++]&mask >> k*3; 
    60:         } 
    61:                                 while (j < IMAGE_SIZE/16 && k == 2) { 
    62:             regtmp[j++] += readbuffer[i++]&bmask >> 6; 
    63:         } 
    64:     } 
    65:         */ 
0x00000674  E1A01005  MOV       R1,R5
0x00000678  E2855001  ADD       R5,R5,#0x00000001
0x0000067C  E0860101  ADD       R0,R6,R1,LSL #2
0x00000680  E1A01004  MOV       R1,R4
0x00000684  E2844001  ADD       R4,R4,#0x00000001
0x00000688  E5902000  LDR       R2,[R0]
0x0000068C  E7971101  LDR       R1,[R7,R1,LSL #2]
0x00000690  E001100B  AND       R1,R1,R11
0x00000694  E0821321  ADD       R1,R2,R1,LSR #6
0x00000698  E5801000  STR       R1,[R0]
0x0000069C  E3550C96  CMP       R5,#0x00009600
0x000006A0  3AFFFFF3  BCC       0x00000674
    66:     printf("Output 'output_rgbcomp.bmp' created.\n"); 
    67:  
0x000006A4  E28F0018  ADD       R0,PC,#0x00000018
0x000006A8  EBFFFF86  BL        $Ven$AT$I$$__2printf(0x000004C8)
    68:     _sys_exit(0); 
0x000006AC  E3A00000  MOV       R0,#0x00000000
0x000006B0  EBFFFEA4  BL        _sys_exit(0x00000148)
    69: } 