    11: int main() { 
    12:     uint8_t *p; 
    13:     uint8_t *rgba; //uint8_t rgba[IMAGE_SIZE]; //RGBA array 
    14:     uint8_t *rgb; //uint8_t rgb[IMAGE_SIZE * 3/4]; //RGB array 
    15:     uint8_t *rgbcomp; //uint8_t rgbcomp[IMAGE_SIZE / 4]; //compressed RGB 
0x00000554  E92D5FF0  STMDB     R13!,{R4-R12,R14}
    16:     p = 0x40000000; //memory pointer - size 4000byte 
0x00000558  E3A0A101  MOV       R10,#__stdout(0x40000000)
    17:     rgba = 0x40200000; 
0x0000055C  E18A74CA  ORR       R7,R10,R10,ASR #9
    18:     rgb = 0x40400000; 
0x00000560  E2878602  ADD       R8,R7,#0x00200000
    19:     rgbcomp = 0x40600000; 
    20:     //0x40200000, 0x407FFFFF Memory Map needed 
0x00000564  E287B501  ADD       R11,R7,#0x00400000
    21:     size_t i = 0; 
0x00000568  E3A04000  MOV       R4,#0x00000000
    22:     size_t j = 0; 
0x0000056C  E3A06000  MOV       R6,#0x00000000
    23:     size_t k = 0; 
    24:  
0x00000570  E3A05000  MOV       R5,#0x00000000
    25:     p = 0x40000000 + HEADER_SIZE;   //fseek(fileIn, HEADER_SIZE-1, SEEK_SET); //set pointer after header 
0x00000574  E3A0A1D9  MOV       R10,#0x40000036
    26:     for(i = 0 ; i<IMAGE_SIZE; i++){ 
0x00000578  E1A00000  NOP       
0x0000057C  EA000002  B         0x0000058C
    27:         rgba[i] = p[i]; 
    28:     } //fread(rgba, sizeof(uint8_t), IMAGE_SIZE, fileIn); //Whole rgba read 
    29:      
0x00000580  E7DA0004  LDRB      R0,[R10,R4]
0x00000584  E7C70004  STRB      R0,[R7,R4]
0x00000588  E2844001  ADD       R4,R4,#0x00000001
0x0000058C  E3540A96  CMP       R4,#0x00096000
0x00000590  3AFFFFFA  BCC       0x00000580
    30:     for (k = 0; k < 3; k++){ //R, G, B  *3 times 
0x00000594  E3A05000  MOV       R5,#0x00000000
0x00000598  EA00000A  B         0x000005C8
    31:         for (i = 0; i < IMAGE_SIZE; i += 4) { 
0x0000059C  E3A04000  MOV       R4,#0x00000000
0x000005A0  EA000005  B         0x000005BC
    32:             rgb[j++] = rgba[i+k];     // RRRGGGBBB order 
    33:         } // Convert RGBA to RGB by ignoring the alpha channel 
    34:     } 
    35:  
0x000005A4  E0840005  ADD       R0,R4,R5
0x000005A8  E7D71000  LDRB      R1,[R7,R0]
0x000005AC  E1A00006  MOV       R0,R6
0x000005B0  E2866001  ADD       R6,R6,#0x00000001
0x000005B4  E7C81000  STRB      R1,[R8,R0]
0x000005B8  E2844004  ADD       R4,R4,#0x00000004
0x000005BC  E3540A96  CMP       R4,#0x00096000
0x000005C0  3AFFFFF7  BCC       0x000005A4
    30:     for (k = 0; k < 3; k++){ //R, G, B  *3 times 
    31:         for (i = 0; i < IMAGE_SIZE; i += 4) { 
    32:             rgb[j++] = rgba[i+k];     // RRRGGGBBB order 
    33:         } // Convert RGBA to RGB by ignoring the alpha channel 
    34:     } 
    35:  
0x000005C4  E2855001  ADD       R5,R5,#0x00000001
0x000005C8  E3550003  CMP       R5,#0x00000003
0x000005CC  3AFFFFF2  BCC       0x0000059C
    36:     unsigned char mask = 0b11100000; //R[7:5], G[7:5] masking 
0x000005D0  E3A090E0  MOV       R9,#0x000000E0
    37:     i = 0; 
0x000005D4  E3A04000  MOV       R4,#0x00000000
    38:     for(k = 0; k < 3; k++){ 
0x000005D8  E3A05000  MOV       R5,#0x00000000
0x000005DC  EA000010  B         0x00000624
    39:         j = 0; 
0x000005E0  E3A06000  MOV       R6,#0x00000000
    40:         while (j < IMAGE_SIZE/4) { 
0x000005E4  EA00000B  B         0x00000618
    41:             rgbcomp[j++] += (rgb[i++] & mask) >> k*3; 
    42:         } 
    43:     } 
    44:      
    45:  
0x000005E8  E1A01006  MOV       R1,R6
0x000005EC  E2866001  ADD       R6,R6,#0x00000001
0x000005F0  E081000B  ADD       R0,R1,R11
0x000005F4  E1A01004  MOV       R1,R4
0x000005F8  E2844001  ADD       R4,R4,#0x00000001
0x000005FC  E7D81001  LDRB      R1,[R8,R1]
0x00000600  E0011009  AND       R1,R1,R9
0x00000604  E0852085  ADD       R2,R5,R5,LSL #1
0x00000608  E1A01251  MOV       R1,R1,ASR R2
0x0000060C  E5D02000  LDRB      R2,[R0]
0x00000610  E0811002  ADD       R1,R1,R2
0x00000614  E5C01000  STRB      R1,[R0]
0x00000618  E3560B96  CMP       R6,#0x00025800
0x0000061C  3AFFFFF1  BCC       0x000005E8
    38:     for(k = 0; k < 3; k++){ 
    39:         j = 0; 
    40:         while (j < IMAGE_SIZE/4) { 
    41:             rgbcomp[j++] += (rgb[i++] & mask) >> k*3; 
    42:         } 
    43:     } 
    44:      
    45:  
0x00000620  E2855001  ADD       R5,R5,#0x00000001
0x00000624  E3550003  CMP       R5,#0x00000003
0x00000628  3AFFFFEC  BCC       0x000005E0
    46:     printf("Output 'output_rgbcomp.bmp' created.\n"); 
    47:  
0x0000062C  E28F0014  ADD       R0,PC,#0x00000014
0x00000630  EBFFFFA4  BL        $Ven$AT$I$$__2printf(0x000004C8)
    48:     _sys_exit(0); 
0x00000634  E3A00000  MOV       R0,#0x00000000
0x00000638  EBFFFEC2  BL        _sys_exit(0x00000148)
    49: } 